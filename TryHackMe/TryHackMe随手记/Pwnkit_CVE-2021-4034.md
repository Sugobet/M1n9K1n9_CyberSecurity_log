# Pwnkit

事实上pwnkit我已经用很多次了，感受到了其通用性的强大，我第一次使用它只是一次偶然的了解到，于是便一发不可收拾。那么我们今天就来了解一下原理吧

---

CVE-2021-4034（俗称“Pwnkit”）是一个可怕的 Local Privilege E扩展 （LPE） 漏洞，位于 Linux 操作系统（以及许多其他 *nix 操作系统）上默认安装的“Polkit”包中。

### 换句话说，它几乎影响了地球上所有主流的Linux系统

该漏洞存在于每个版本的“策略工具包”（或 Polkit）包中，并允许任何非特权攻击者轻松获得对安装了 Polkit 包的任何 Linux 计算机的完全管理访问权限。不幸的是，Polkit 默认安装在大多数 Linux 发行版上，这使得这个漏洞非常普遍。

Polkit 的易利用性和无处不在的性质使其成为绝对毁灭性的漏洞;但是，幸运的是，它无法远程利用，使 Pwnkit 纯粹是一个本地权限提升 （LPE） 漏洞。

简短的版本是这样的：在补丁之前发布的 pkexec 版本无法安全地处理命令行参数，这会导致“越界写入”漏洞，允许攻击者操纵运行 pkexec 的环境。这就是您真正需要知道的全部内容，但有关技术性更强的解释，请继续阅读！

更具体地说，pkexec 尝试解析我们使用 for 循环传递它的任何命令行参数，从索引 1 开始偏移程序名称并获得第一个真实参数（例如，如果我们输入 pkexec bash, 然后作为 pkexec 是程序的名称，它将是参数 0 — 实际的命令行参数从索引 1 开始）。程序的名称与参数解析无关，因此索引只是偏移以忽略它。

    for(n=1; n < number_of_arguments; n++){
    //Do Stuff
    }

如果参数数为 0，则 n 永远不会少于参数的数量。因此, n 保持等于 1，循环被完全绕过.

当 pkexec 尝试写入索引处参数的值时，这在以后会成为一个问题 n. 由于没有命令行参数，因此索引处没有参数 n — 相反，程序会覆盖内存中的下一件事，当使用名为 C 函数调用程序时，它恰好是环境变量列表中的第一个值 execve(). 换句话说，通过向 pkexec 传递一个空参数列表，我们可以强制它覆盖环境变量！

对于上下文：当您尝试运行设置了 SUID 位的程序时，操作系统会删除某些“危险”环境变量（就像 pkexec 一样）;这是为了防止攻击者在使用管理权限运行时劫持程序。使用越界写入，我们能够通过欺骗 pkexec 为我们添加这些危险环境变量来重新引入我们对这些危险环境变量的选择。有各种不同的方法可以滥用它，所有这些都会导致以 root 用户的身份执行代码。

---

防御方法：

    1.升级到polkit的打了修复补丁的版本
    2.使用chmod 0755修改pkexec的权限，取消其suid位
