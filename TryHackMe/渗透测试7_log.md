# 被动侦察

whois、https://dnsdumpster.com/、nslookup的使用，侦察网站的公开信息

# 主动侦察

浏览器的开发者工具、ping、traceroute、netcat的使用



都非常简单曾经做开发、做爬虫的时候没少干



# Network Mapper

#### nmap -sn ，扫主机但不扫端口

    -PR ，arp扫描

    -PE ，ICMP echo (ping)扫描

有时候某些主机的操作系统禁ping(icmp echo request)，可以尝试以下icmp包扫描

    -PP ，ICMP timestamp时间戳请求扫描

    -PM ，ICMP address mask掩码请求扫描

### tcp探测

    nmap -sn -PS  <PORT>，tcp syn扫描

    nmap -sn -PA <PORT>，tcp ack扫描

默认扫80端口

syn ping不需要账号特权，ack ping需要

### udp探测

    nmap -sn -PU <PORT>， udp扫描
    默认扫随机的奇葩端口

tryhackme提到一个点就是如果目标主机不在线，那么向它的udp端口发送udp包，此时我们是无法获得任何响应的，很简单，因为目标主机不在线；但如果目标主机在线，并且存在 端口状态是关闭的udp端口，此时我们发送udp数据包，是可以获得响应的。

这样，就可以根据有没有响应来判断目标是否在线



# Nmap 端口扫描

上面探测完哪些主机在线，那么接下来就要对其进行端口扫描

### TCP端口扫描

    nmap -sT ，TCP全连接端口扫描

    nmap -sS ，tcp半连接扫描
    (如果是root，才能够发起tcp半连接; 如果不是root，则会发起tcp全连接)


### UDP端口扫描

如果我们向开放的UDP端口发送UDP数据包，则无法期望任何回复。因此，将UDP数据包发送到打开的端口，我们得不到任何响应(ICMP 目标不可达)。

我分析以下，此时就有两种情况，

    1.该udp探测包没有被防火墙等安全设备拦截，则将表明端口是打开的
    2.该udp探测包被防火墙等拦截，此时虽然没有给我们响应，
    但我们仍无法得知究竟是被拦截还是成功发送至目标端口，无法得知端口状态

nmap -sU ，udp端口扫描


### 扫描范围

    nmap -p- ，即扫描所有端口
    nmap -F ，扫描常见的100个端口
    nmap --top-ports <num> ，扫描常见的num个端口

### 扫描速度

    nmap有0-5，由小到大，速度依次提升

    nmap -T<num> ，设置速度


### 高级端口扫描

    nmap -sN ，null flag扫描
    (端口打开或被防火墙拦截将不会有响应，否则将收到rst ack)

    nmap -sF ，fin扫描
    (同上)

    nmap -sX ，圣诞节扫描 URG|FIN|PSH 置位1，我也不知道为什么叫圣诞节扫描
    反正微软翻译过来就是这样子
    (同上)

### TCP ack端口扫描

    nmap -sA

ack端口扫描有意思的点在于，nmap发送ack置位1数据包，经过抓包分析，分两种情况:

1.端口是开启，对端收到后检查数据包但该tcp连接不存在，那么对端将会发送rst

2.端口是关闭，那么我们将也会收到rst

这意味着我们将无法通过ack数据包判断端口的状态，但是有一点值得注意：

    如果非法ack数据包被防火墙等ASPF设备拦截，
    那么我们将不会收到rst响应！因此，
    我们可以通过ack端口扫描判断是否有安全设备拦截，
    以及知道拦截了哪些端口、没有拦截哪些端口

用tryhackme的原话来说：

    仅仅因为防火墙没有阻止特定端口，并不一定意味着服务正在侦听该端口。
    例如，防火墙有可能 需要更新规则以反映最近的服务更改。
    因此，ACK 和Window扫描会暴露防火墙 规则，而不是服务。


# 空闲扫描

    nmap -sI <zomble_ip> ，idle扫描

原理比较有意思，利用到了ip包头的identification字段，主机每发一个ip包，该值将会递增1。

利用这个特点，我们可以尝试在网络上找一些足够闲的主机，比如网络打印机设备等，足够闲是为了方便我们进行根据id的变化情况进行判断。

#### 以下均被我抓包严谨分析过:

首先我们伪造:

    设：空闲设备当前的ip id为0

    源地址为空闲主机的ip地址
    目的地址为被扫描目标ip地址

的tcp syn数据包，此时又分两种情况：

1.该数据包被安全设备拦截，没有到达被扫描目标设备，那么此时空闲主机将不可能收到syn ack或rst ack的数据包，则ip id=0

#### 2.该数据包到达被扫描目标，此时将会回syn ack或rst ack包给空闲主机，此时又分两种情况：

(1).空闲主机收到syn ack，即被扫描设备的某个端口开启，那么空闲主机将会回rst包给被扫描设备，此时ip id将会被加1，即 ip id=1。

(2).空闲主机收到rst ack，即被扫描设备的某个端口关闭，根据协议，空闲主机不会对rst ack回包，则此时ip id=0


若此时，我们作为攻击者发送任意能使空闲主机回复我们的tcp数据包，如：syn ack，那么空闲主机将会回rst包给我们，此时ip id会加1.

由此可见，如果被扫描目标的端口为开启，我们将能够观察到ip id + 2，相反如果为关闭或被安全设备拦截则 + 1。

以上的前提是，空闲主机足够的空闲，否则无法准确的判断ip id变化是否为以上情况.
